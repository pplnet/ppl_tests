ACT(A:1,'string')
ACN(A:2,1)
ACN(A:3,12.2)

test("kvm", ->{
    &prueba := ${STRING1='string', CANTIDAD1=1, PRECIO1=12.2}
    &prueba2 := ${STRING1=Val(A:1), CANTIDAD1=Val(A:2), PRECIO1=Val(A:3)}
    &prueba3 := ${STRING1='string', CANTIDAD1=NewPplObj('1',SI,SI), PRECIO1=NewPplObj('12.2',SI,SI)}
    &prueba4 := ${STRING1='string', CANTIDAD1=Num('1'), PRECIO1=Dbl(12.2)}
    &prueba5 := ${STRING1='string', CANTIDAD1=Int(1), PRECIO1=Dbl(12.2)}

    assertEq('string', &prueba.STRING1)
    assertEq(1, &prueba.CANTIDAD1)
    assertEq(12.2, &prueba.PRECIO1)
    assertEq(1, &prueba2.CANTIDAD1)
    assertEq(12.2, &prueba2.PRECIO1)
    assertEq(1, &prueba3.CANTIDAD1)
    assertEq(12.2, &prueba3.PRECIO1)
    assertEq(1, &prueba4.CANTIDAD1)
    assertEq(12.2, &prueba4.PRECIO1)
    assertEq(1, &prueba5.CANTIDAD1)
    
    ** Si no existe la clave, devuelve null
    assertEq(NULL, &prueba.STRING2)
})

test("kvm set kvmprop", ->{
    &suscripcion := ${codigo='FCS', nombre='Suscripcion de fondos', tipo='FCI'}
    &rescate := ${codigo='FCR', nombre='Rescate de fondos', tipo = &suscripcion.tipo}
    
    assertEq('FCI', &suscripcion.tipo)
    assertEq('FCI', &rescate.tipo)
})

test("kvm props case insensitive", ->{
    &op := ${codigo = 'MMPF', NOMBRE='Plazo Fijo'}
    
    assertEq('MMPF', &op.codigo)
    assertEq('MMPF', &op.CODIGO)
    assertEq('Plazo Fijo', &op.nombre)
    assertEq('Plazo Fijo', &op.NOMBRE)
})

test("kvm add kvmprop", ->{
    &persona := ${nombre = 'Pepe'}
    &persona.add(apellido = 'Argento', dni = 12345678)
    assertEq('Argento', &persona.apellido)
    assertEq(12345678, &persona.dni)
    
    &persona.add(tel = NewPplObj('5555555',SI,SI), FechaNac = Fecha('02/01/2020'))
    assertEq(5555555, &persona.tel)
    assertEq(Fecha('02/01/2020'), &persona.FechaNac)
    
    &persona.add('Direccion', 'Calle Falsa 123')
    assertEq('Calle Falsa 123', &persona.Direccion)
    
    &propTrabajo := 'trabajo'
    &empresa := 'FPA Software'
    &persona.add(&propTrabajo, &empresa)
    assertEq('FPA Software', &persona.trabajo)
    
    &nombre := ${nombre = 'Pepito'}
    &persona.add(&nombre)
    assertEq('Pepito', &persona.nombre)
})

test("kvm remove kvmprop", ->{
    &persona := ${nombre = 'Pepe', apellido = 'Argento', dni = 12345678, tel = NewPplObj('5555555',SI,SI), FechaNac = Fecha('02/01/2020')}
    &persona.remove('apellido')
    &persona.remove('dni')
    assertEq('Pepe', &persona.nombre)
    assertEq(NULL, &persona.apellido)
    assertEq(NULL, &persona.dni)
    
    &propTel := 'tel'
    
    &persona.remove(&propTel)
    &persona.remove('FechaNac')
    assertEq(NULL, &persona.tel)
    assertEq(NULL, &persona.FechaNac)
})

test("kvm contains kvmprop", ->{
    &persona := ${nombre = 'Pepe', apellido = 'Argento', dni = 12345678, tel = NewPplObj('5555555',SI,SI), FechaNac = Fecha('02/01/2020')}
    &persona.remove('dni')
    assertEq(SI, &persona.contains('nombre'))
    assertEq(SI, &persona.contains('NOMBRE'))
    assertEq(SI, &persona.contains('apellido'))
    assertEq(SI, &persona.contains('APELLIDO'))
    assertEq(NO, &persona.contains('dni'))
    assertEq(NO, &persona.contains('DNI'))
    &persona.add(dni = 12345678)
    assertEq(SI, &persona.contains('dni'))
    assertEq(SI, &persona.contains('tel'))
    assertEq(SI, &persona.contains('TEL'))
    assertEq(SI, &persona.contains('FechaNac'))
    assertEq(SI, &persona.contains('FECHANAC'))
})

test("kvm anidado", -> {
    &prueba := ${STRING1='string',SUBKVM=${ENTERO1=10}}
    assertEq('string', &prueba.STRING1)
    *Este caso por el momento no lo vamos a soportar
    *assertEq(10, &prueba.SUBKVM.ENTERO1)
    *El workarround es setearlo en una variable temporal
    &tmp := &prueba.SUBKVM
    assertEq(10, &tmp.ENTERO1)
})

test("kvm count", ->{
    &op := ${codigo='MMPF', nombre='Plazo Fijo', count=30}
    &op.remove('nombre')
    assertEq(30, &op.count)
    assertEq(2, &op.count())
})

test("kvm for in", -> {
    &kvm := ${key1=1, key2=2, key3=3}
    &counter := 1
    &counter2 := Num('1')
    &counter3 := Int(1)
    &counter4 := NewPplObj('1',SI,SI)
    
    for &val in &kvm
       &key := 'key'~FSTR(&counter,0,0)
       assertEq(&key, &val.get_key)
       assertEq(&kvm.get(&key), &val.get_value)
       assertEq('key'~FSTR(&counter,0,0), &val.get_key)
       assertEq(&kvm.get('key'~FSTR(&counter,0,0)), &val.get_value)
       
       &key2 := 'key'~FSTR(&counter2,0,0)
       assertEq(&key2, &val.get_key)
       assertEq(&kvm.get(&key2), &val.get_value)
       assertEq('key'~FSTR(&counter2,0,0), &val.get_key)
       assertEq(&kvm.get('key'~FSTR(&counter2,0,0)), &val.get_value)
       
       &key3 := 'key'~FSTR(&counter3,0,0)
       assertEq(&key3, &val.get_key)
       assertEq(&kvm.get(&key3), &val.get_value)
       assertEq('key'~FSTR(&counter3,0,0), &val.get_key)
       assertEq(&kvm.get('key'~FSTR(&counter3,0,0)), &val.get_value)
       
       &key4 := 'key'~FSTR(&counter3,0,0)
       assertEq(&key4, &val.get_key)
       assertEq(&kvm.get(&key4), &val.get_value)
       assertEq('key'~FSTR(&counter3,0,0), &val.get_key)
       assertEq(&kvm.get('key'~FSTR(&counter3,0,0)), &val.get_value)
       
       &counter := &counter + 1
       &counter2 := &counter2 + 1
       &counter3 := &counter3 + 1
       &counter4 := &counter4 + 1
    end
})

test("kvm for in anidados", -> {
    &kvm1 := ${key1=1, key2=2, key3=3}
    &kvm2 := ${key1=4, key2=5, key3=6}
    &counter := 1
    
    for &val in &kvm1
       &key := 'key'~FSTR(&counter,0,0)
       assertEq(&key, &val.get_key)
       assertEq(&kvm1.get(&key), &val.get_value)
       assertEq('key'~FSTR(&counter,0,0), &val.get_key)
       assertEq(&kvm1.get('key'~FSTR(&counter,0,0)), &val.get_value)
       &counter := &counter + 1
       
       &counter2 := 1
       for &val1 in &kvm2
          &key2 := 'key'~FSTR(&counter2,0,0)
          assertEq(&key2, &val1.get_key)
          assertEq(&kvm2.get(&key2), &val1.get_value)
          assertEq('key'~FSTR(&counter2,0,0), &val1.get_key)
          assertEq(&kvm2.get('key'~FSTR(&counter2,0,0)), &val1.get_value)
          &counter2 := &counter2 + 1
       end 
    end
})

test("kvm recorrer&i", -> {
    &kvm := ${key1=1, key2=2, key3=3}
    recorrer&k 1, 3
      assertEq(&k, &kvm.get('key'~FSTR(&k,0,0)))
    proximo
})

test("kvm error", ->{
    &prueba := ${STRING1='string'}

    assertEq('string', &prueba.STRING2)
})
